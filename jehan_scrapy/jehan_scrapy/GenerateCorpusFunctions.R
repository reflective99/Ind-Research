library("gtools")
library("RcppArmadillo")
library("Matrix")
Rcpp::sourceCpp("scripts/GenerateCorpusFunctions.cpp")


#The pareto distribution is f(x) = (a * x_m^a)/x^(a+1), where x_m is the scale, and a is the shape
#a is most similar to the powerlaw parameter

#ppareto <- function(x, scale, shape){
# Calculate the cdf for the pareto distribution
#
#Args: 
#  x: type double, value the cdf should be evaluated at
#  scale: type double, scale parameter for the pareto distribution
#  shape: type double, the shape parameter for the pareto distribution
#
#Returns: type double, value of the cdf for the given distribution
#############################################################################

#Compute CDF value
# ifelse(x > scale, 1 - (scale / x) ^ shape, 0)

#}

#qpareto <- function(y, scale, shape){
# Calcualte the inverse cdf for the pareto distribution
#
#Args:
#  y: type double, the CDF value for which the inverse is to be calculated
#     Will return NaN if not between 0 and 1. 
#  scale: type double, scale parameter for the pareto distribution
#  shape: type double, the shape parameter for the pareto distribution
#
#Returns: type double, b
#############################################################################

#compute inverse CDF
# ifelse(
#    y >= 0 & y <= 1,
#   scale * ((1 - y) ^ (-1 / shape)),
#    NaN
#  )

#}

#Rpareto <- function(n, scale, shape){
#lower_bound = scale, upper_bound = Inf){
# Randomly sample n observations from a pareto distribution 
# with the specified shape and scale. lower_bound and 
# upper_bound arguments are recommended
#
#Args:
#  n: Integer, number of samples to be drawn
#  scale: double, scale parameter for pareto distribution
#  shape: double, shape parameter for the pareto distribution
#  lower_bound: positive double, the minimum value that a draw
#               is allowed to take. Defaults to the scale parameter.
#  upper_bound: double, must be greater than lower_bound. The maximum
#               value that a draw is allowed to take. Defaults to Infinity
#
#Returns: A list of length n filled with draws of type double from a pareto
#         with the specified scale and shape parameters
#############################################################################

#Take quantiles of the lower and upper bounds
#quantiles <- ppareto(c(lower_bound, upper_bound), scale, shape)

#Draw a CDF value uniformly between the upper and lower allowed quantiles 
#uniform_random_numbers <- runif(n, quantiles[1], quantiles[2])    

#Return the inverse-CDF transformation the uniform draws
#return(qpareto(uniform_random_numbers, scale, shape))

#}




GenerateCorpus = function(k=10, zipf=T,alpha =1.1, ndocs =1000, 
                          avg.length.doc =255,nvocab = NULL, 
                          talk = F){
  # Given a number of topics (k), number of documents (ndocs),
  # avg. length of doc, and a method for generating multinomial
  # counts, and an optional length of vocab (default to an 
  # approximation based on expected number of words), 
  # returns a corpus ready to be analyzed with LDA
  #
  #Args: 
  #  k: Integer. the number of topics to generate the corpus from, 
  #     Defaults to 10.
  #  zipf: Logical. if TRUE, Will generate the documents using a power law 
  #        distribution over the topic expressions. If false, will generate the
  #        documents with a symmetric Dirichlet distribution over the topic
  #        expressions. Default is TRUE.
  #  alpha: Double. The power law parameter for zipfian corpus generation.
  #         Is not necessary unless zipf = T. Default is 1.1.
  #  ndocs: Integer. The number of documents that should be generated by the
  #         corpus. Default is 1000.
  #  avg.length.doc: Integer. The average length of the document. This is used 
  #                  as a poisson parameter when generating document lengths.
  #                  The default value is 255, average abstract length.
  #  nvocab:  Integer or NULL. The number of tokens or vocabulary terms to use 
  #           when generating the corpus and documents. If NULL, the value is 
  #           imputed from using the avg.length.doc and ndocs with zipfs law 
  #           to find an approximate value, with 1.4 being the power law.
  #           The default value is NULL.
  #  talk:  Logical. If TRUE, will give updates as it progresses. If FALSE,
  #         then it will not. Default is FALSE.
  #  
  #Returns: 
  #  corpus: A sparse representation of the documents comprising the corpus
  #          This is formatted to be directly put into functions from the 
  #          'lda' package by Jonathan Chang. The associated terms are 
  #          named "1", "2",... "100" up to nvocab
  #  mytopics: Matrix double, nvocab x k. Columns are the true topic
  #            expressions. 
  #  myproportions: Matrix double, k x ndocs. Rows contain the true
  #                 topic proportions
  #############################################################################
  
  if(is.null(nvocab)){
    
    #approximation based on zipfs law
    nvocab <- (ndocs*avg.length.doc)^(1/1.4)       
    
  }
  
  #First, generate topics
  if(talk){ 
    print('Generating Topics') 
  }
  
  mytopics <- GenerateTopics(K = k, zipf = zipf, alpha = alpha, V = nvocab)
  
  #Next generate topic proportions
  if(talk){
    print('Generating Topic Proportions')
  }
  
  proportions <- GenerateProportions(ndocs = ndocs, K = k)
  
  #Now, generate documents
  if(talk){ 
    print('Generate Documents')
  }
  
  corpus <- GenerateDocuments(props = proportions, mytops = mytopics, 
                              ndocs = ndocs, K = k, V = nvocab, 
                              lambda = avg.length.doc, talk = talk)
  
  return(list("corpus" = corpus, "mytopics" = mytopics,
              "myproportions" = proportions))
  
}

GenerateTopics  = function(K , V, zipf = T, alpha = 1.1){
  #Given a method for generating topics (symmetric or zipfian)
  #generate topics for the LDA model
  #
  #Args: 
  #  K: Integer. The number of topics to generate
  #  V: Integer. The number of vocabulary terms the topics should distribute
  #  zipf: Logical. If TRUE, generates topics according to a shuffled power
  #        law. If FALSE, generates symmetric topic expressions. 
  #        Defaults to TRUE.
  #  alpha: Double. If zipf=TRUE, alpha is the power law parameter to use
  #         for the topic generation. If zipf = FALSE, then alpha is the
  #         concentration parameter for the symmetric dirichlet
  #         generating distribution. 
  #
  #Returns: Matrix double, nvocab x k. Columns are the true topic
  #         expressions.
  #############################################################################
  
  if(zipf){
    #Asymmetric generation (Zipfian)
    
    mytopics <- matrix(0, nrow = V, ncol = K)
    
    samp.prob <- rep(1/V,V)
    
    dirichlet.param <- GenerateDirichletParam(V, alpha = alpha)
    
    #Using generated power law, sample different shufflings for the 
    #topic generation
    for(i in 1:K){
      
      assym.dirichlet <- sample(x = dirichlet.param,
                                size = V, replace = F,
                                prob = samp.prob) 
      
      #reweight the shuffling so that the same words don't become dominant
      #in multiple topics, induce a seperation between topics
      samp.prob <- samp.prob/assym.dirichlet
      
      samp.prob <- samp.prob/sum(samp.prob) 
      
      mytopics[,i] <- rdirichlet(n = 1, alpha = assym.dirichlet)[1,]
    }
    
  } else {
    #Symmetric generation of the topic expressions
    
    #Get concentration parameter for dirichlet
    if(is.null(alpha)){
      
      alphasym = rep(1/V,V)
      
    } else {
      
      alphasym = rep(alpha,V)
    }
    
    #sample Topics
    mytopics = t(rdirichlet(n = K, alpha = alphasym))
    
  }  
  
  return(mytopics) 
  
}

GenerateProportions = function(ndocs, K = 10, alpha = rep(1/K,K)){
  #Generate topic proportions for each document
  #
  #Args:
  #  ndocs: Integer. The number of documents to generate proportions for
  #  K: Integer. The number of topics to generate proportions over. 
  #  alpha: Integer vector length K. The concentration parameter for
  #         the dirichlet distribution. Can be symmetric or asymmetric
  #
  #Returns: Matrix double, k x ndocs. Rows contain the true
  #         topic proportions
  #############################################################################
  
  #Generate proportions
  proportions = t(rdirichlet(n = ndocs, alpha = alpha))
  
  return(proportions)
  
}

GenerateDirichletParam = function(V, alpha = 1.1){
  #Generates the base measure for the topic expression distribution.
  #This generates a deterministic power law distribution based on 
  #alpha, the power law parameter.
  #
  #Args: 
  #  V: Integer. The length of the desired dirichlet parameter.
  #  alpha: Double. The power law parameter. Default is 1.1.
  #
  #Returns: Double vector, length V. This can be used as a dirichlet
  #         concentration parameter.
  #############################################################################
  
  #Initialize the dirichlet parameter as scaling
  rank = 1:V
  #compute powerlaw
  dir.par = rank^alpha
  dir.par = dir.par/sum(dir.par)
  
  return(dir.par)
}

GenerateDocuments = function(props, mytops, lambda,
                             ndocs, expect = F, K = 10, V, talk = F ){
  #Generates a corpus of documents according to either the
  #expectation or an LDA type mechanism. Takes arguments
  #generated in and provided to generate.corpus(...)
  #
  #Args:
  #  props: Double Matrix, K x D. Topic proportions for each documents
  #  mytops:  Double Matrix, V x K. Topic expressions
  #  ndocs: Integer. Number of documents in the corpus.
  #  K: Integer. Number of topics. Default is 10.
  #  expect: Logical. If TRUE, words are allocated in expectation of the
  #          proportions and topics, by using the expected DTM. If FALSE,
  #          then the LDA Ball-Urn generative mechanism is used.
  #          Using TRUE is faster for smaller problems, however since it
  #          can yield large dense matrices using symmetric Dirichlet priors
  #          FALSE may sometimes be more memory efficient in dense problems.
  #          Default is FALSE since it is safer for memory.
  #  lambda: Integer (can be double). Poisson parameter for generating
  #          document lengths
  #  talk:  Logical. If TRUE, will update on status of the function
  #         progressing since it may run slowly. If False, it won't.
  # 
  #Returns: A sparse representation of the documents that is consistent with
  #         Jonathan Chang's "lda" package's required inputs. 
  #############################################################################
  
  #Draw document lengths
  doclengths <- rpois(n = ndocs,lambda = lambda);
  
  if(expect){
    
    #Calculate expected DTM
    dtm <- mytops %*% props
    
    if(talk){
      print('Generating document 1')
    }
    
    #Produce valid integer counts for each word in the DTM.
    for(i in 1:length(doclengths)){
      
      if(talk){ 
        if(i%%100 == 0){
          print(paste('Generating document', i,'at',Sys.time(),sep = " "))
        }
      }
      
      dtm[,i] <- round(dtm[,i] * doclengths[i])
      
    }
    
  } else {
    
    #Generate the DTM via the LDA Ball + Urn generative method
    dtm <- LdaGeneratecpp(props_ = props,tops_ = mytops,
                          dlengths_ = doclengths, D = ndocs, K=K,
                          V = V, talk = talk)
  }
  
  #lexicalize the dtm
  docs <- MakeDocs(dtm = dtm)
  
  return(docs)
}

RLdaGenerate = function(props, mytops, dlengths, D, K, V, talk = F){
  #Uses the Ball and Urn style mechanism of LDA to generate
  #a valid Document Term Matrix
  #
  #Args:
  #  props: Double Matrix, K x D. Topic proportions for each document
  #  mytops: Double Matrix, V x K. Topic expressions 
  #  dlengths: Integer vector, length D. Lengths of each document 
  #  D: Integer. Number of documents
  #  K: Integer. Number of topics
  #  V: Integer. Number of Vocabulary terms or tokens.
  #  talk: Logical. If TRUE, gives updates on progress. If FALSE, not.
  #
  #Returns: Integer Matrix, V x D. Document term matrix.
  #############################################################################
  
  #Intialize the document term matrix
  dtm <- matrix(0, nrow = V, ncol = D)
  
  if(talk){
    print("Generating document 1")
  }
  
  for(d in 1:D){
    
    if(talk){
      if(d%%100==0){
        print(paste("Generating document",d,"at",Sys.time(),sep=" "))
      }
      
    }
    
    for(w in 1:dlengths[d]){
      
      topic.draw <- rmultinom(1, size = 1, prob = props[,d])
      top <- as.integer(which(topic.draw>0,arr.ind = T)[1,1])
      
      vocab.draw <- rmultinom(1, size = 1, prob = mytops[,top])
      v <- as.integer(which(vocab.draw>0,arr.ind =T)[1,1])
      
      dtm[v,d] <- dtm[v,d]+1
      
    }
    
  }
  
  return(dtm)
  
}

MakeDocs = function(dtm){
  #Turns a dtm into the sparse representation of documents that 
  #is expected as an input to functions from the "lda" package written
  #by Jonathan Chang. 
  #Args:
  #  dtm: Integer Matrix, V x D. document-term matrix, multinomial counts
  #
  #Returns:
  #  List of length D. Each element is a matrix 2 x (length of document),
  #  with the first row corresponding to the index of the vocabulary term
  #  and the second row corresponding to the counts (to be compatible with
  #  Jonathan Changs "lda" package, this is always 1 and repeated words are
  #  counted by having multiple entries)
  #############################################################################
  
  #Get dimensions
  D <- dim(dtm)[2]
  
  V <- dim(dtm)[1]
  
  #Intialize docs representation
  docs <- vector("list",D)
  
  #Process each document - get from the dtm the number of times that 
  #each word occurs, and the document length. 
  for(i in 1:D){
    
    #Copy the row corresponding to the ith document
    row <- dtm[,i]
    
    #Get the indices of terms that occur in that doc
    Vindx <- which(row>0)
    
    #Get the counts of each word
    counts <- row[Vindx]
    
    #Go through the document and get the cumulative count
    #this allows us attribute the vocab
    cumcounts <- rep(0, length(counts))
    
    cumcounts[1] <- counts[1]
    
    for(c in 2:length(cumcounts)){
      
      cumcounts[c] <- counts[c]+ cumcounts[c-1]
      
    }
    
    nlex <- sum(counts)
    
    vrow <- rep(0,nlex)
    
    frow <- rep(1, nlex)
    
    for(j in 1:nlex){
      
      ix <- which(j<=cumcounts)[1]
      
      vrow[j] <- Vindx[ix]
      
    }
    
    doc <- as.matrix(rbind(as.integer(vrow-1),as.integer(frow)))
    
    docs[[i]] <- doc 
    
  }
  
  return(docs)
}


SimulatedCorpusLength = function(corpus, doc.level = F){
  #Returns the total number of words that are contained in a corpus
  #that is in the format expected by lda.colllapsed.gibbs.sampler or
  #returns a vector of lengths of the documents
  #
  #Args:
  #  corpus: List of Length D, of Integer matrices 2xN.d, where N.d is the
  #          length of document d in the corpus. This is the structure
  #          that is output by GenerateCorpus and expected by Jonathan
  #          Chang's "lda" package. 
  #  doc.level: Logical. If TRUE, then returns an integer vector of counts
  #             corresponding to the document lengths in the corpus.
  #             If FALSE, returns the total corpus length.
  #             Default is FALSE.
  #
  #Returns:
  #  Either the total number of words in a corpus if doc.level =F
  #  or returns a vector containing the length of each document in the corpus
  #############################################################################
  
  #If only the whole corpus length is requested
  if(!doc.level){
    
    corpus.length <- 0
    
    for(i in 1:length(corpus[[1]])){
      
      corpus.length <- corpus.length + dim(corpus[[1]][[i]])[2]
      
    }
    
    return(corpus.length)
    
  } else {
    #If the length of each document is requested
    
    corpus.length <- rep(0,length(corpus))
    
    for(i in 1:length(corpus)){
      
      corpus.length[i] <- dim(corpus[[i]])[2]
      
    }
    
    return(corpus.length)
    
  }
  
}


GenerateCorpusFast = function(d, v, k, a, b, l = F, t, dir.conc = 1, use.dir=F){
  #Generate a sparse dtm in a faster way, using the topics x topic proportions
  #method for getting the topics.
  #
  #Args:
  # d: integer. The number of documents
  # v : integer. Number of vocab terms
  # k: integer. Number of topics.
  # a: double. Pareto shape parameter (scale is always 1)
  # b: double. Dirichlet concentration parameter for proportions
  # l: number of non-zero terms in each topic
  # t: integer. Total number of tokens to generate
  # dir.conc: double, dirichlet concentration parameter for the prior
  # use.dir: boolean. Whether to use dirichlet sampling or to just scale
  #         the pareto draw to be the multinomial topic
  #
  #Returns:
  # dtm: sparse dtm representation
  # lex: list sparse representation
  #############################################################################
  if(l == F){
    l <- ceiling(v/k)
  }
  
  #Initialize dtm
  #dtm <- sparseMatrix(i = d, j = v)
  #initialize topics
  topics <- sparseMatrix(i = k, j = v)
  proportions <- sparseMatrix(i = d , j = k)
  
  #generate topics
  for(i in 1:k){
    
    #Get topic expressions
    topic <- rpareto(n = l, scale = 1, shape = a)
    
    if(use.dir){
      
      topic <- rdirichlet(n = 1, alpha = dir.conc*topic/sum(topic))[1,]
      
    }else{
      
      topic <- topic/sum(topic)
      
    }
    
    topic <- sparseVector(x = topic, 
                          i = sample.int(n = v, size = l), 
                          length = v)
    
    topics[k,] = topic
    
    #Get topic proportion
    
    proportions[,k] = rdirichlet(n = 1, alpha = rep(b, d))[1,]  
    
  }
  
  dtm = proportions %*% topics * t;
  
  return(dtm)
  
}




